---
title:  "AIFM: Application-Integrated Far Memory"
date:   2022-06-20 15:29:03 +0900
categories: RDMA Paging
author_profile: true
toc: true
toc_sticky: true
toc_label: "AIFM"
---
High-Performance, Application-Integrated Far Memory

[출처] OSDI'20: Proceedings of the 14th USENIX Conference on Operating Systems Design and Implementation, November 2020, Article no.18, Pages 315-332

## 1.	배경
부족한 메모리와 I/O 증폭에 의한 페이징 속도 저하 등 해결법으로 AIFM을 제시

메모리는 CPU에 비해 사용량이 많으면서도 유연하지 못한 리소스이다. 예를 들어, 서버가 메모리를 초과하는 응용을 실행하면 어떤 응용은 강제 종료된다. 이는 클러스터나 로컬의 다른 서버에 사용 가능한 메모리가 있을 때도 발생한다.

이에 대한 방안으로 스왑 기능이 있다. 하지만 스왑 기능을 사용하는 페이징 기법은 페이지 크기가 고정적이기 때문에 발생하는 프레그멘테이션과 페이지를 폴트를 다룰 때 커널 모드로의 전환에서 오버헤드가 발생하는 한계점이 있다.

따라서 AIFM은 다음과 같은 목표를 가진다.
-	AIFM은 RAM와 Far Memory가 동일한 접근 시간을 가진다.
-	로컬과 원격 둘 다 사용 가능한 하이브리드 자료구조를 제공한다.

    **이를 통해 응용이 원격 메모리를 사용하도록 함**


## 2.	소개

**AIFM의 기여**
1.	서버의 메모리를 사용하여 메모리 크기를 확장
2.	응용과 원격 자료구조의 개발을 위한 편리한 API를 갖춘 AIFM의 구현
3.	로컬 객체 접근 오버헤드를 최소화하고 원격 객체 데이터를 기다릴 때 낭비를 방지하는 중단 없는 메모리 제거기와 녹색 스레드의 사용하는 고성능 런타임 설계

부족한 메모리에 대해 페이징 기법의 한계를 넘어 새로운 방안을 제시. 이것은 응용이 원격 메모리를 사용하도록 하는 것인데, 메모리의 용량 부족 문제를 원격 메모리를 통해 해결하고, RAM과 원격 메모리에 동일한 접근 시간을 통해 페이징 기법의 한계를 뛰어넘는 것이 목표이다.

페이징이 가지던 한계를 AIFM은 두 가지 방법으로 극복한다. 페이지와 달리 개별 응용 수준으로 메모리 개체와 스왑 연결한다. 이는 지연시간이나 응용의 처리량에 방해되지 않도록 로컬과 원격 메모리 둘 다 사용가능한 하이브리드 자료구조를 사용함으로써 가능하다. 

메모리가 부족할 때, AIFM 런타임은 객체를 원격 메모리로 스왑 아웃하여 메모리 부족을 극복한다. 응용이 원격 포인터를 역참조하면, 런타임은 녹색 스레드를 사용하여 로컬 메모리에 복원한다. 녹색 스레드는 커널 모드로의 전환이 필요 없기 때문에 문맥 전환 비용이 적게 발생하고, 역참조하는 동안 다른 녹색 스레드가 블록되지 않고 대기 시간을 생산적으로 사용하기 때문에 높은 처리량을 유지하게 된다. 오버헤드 문제 극복

AIFM 프로그래밍 인터페이스 핵심 4가지
- **빠르고 오버헤드가 적은 원격 포인터 추상화**
- **중단 없는 메모리 제거기**
- **의미 정보 전달 런타임**
- **원격 메모리에 오프로드 하는 데 도움이 되는 장치 인터페이스**


## 3.	설계
### 3-1. 개요
AIFM은 자료구조 라이브러리와 런타임 라이브러리로 크게 2가지 라이브러리로 구성되어 있다.

<p align="center">
    <img src="https://user-images.githubusercontent.com/56579239/176813330-55606560-066d-479f-a3e3-130b955bbf65.png">
</p>

응용은 AIFM 런타임이 제공하는 API(Yellow)와 프리미티브 사용하여 구현된 원격 자료구조(Grey)와 상호 작용한다. 이것은 응용 개발자들에게 익숙한 API를 가진 자료구조를 제공하여 원격 자료구조를 블랙박스 취급할 수 있게 한다.

### 3.2. 원격 메모리 추상화
AIFM은 로컬 개체에 대한 hot path 접근에는 최소 오버헤드를 부과하고, cold path 원격 접근에는 하드웨어 제한보다 적은 지연 시간이 발생하도록 추상화를 설계한다.

<h4> 3.2.1. 원격 가능한 포인터 </h4>

> 원격 가능한 포인터는 현재 로컬에 저장됐던 원격에 저장됐던 메모리에 할당된 객체를 의미한다. AIFM은 unique 원격 가능 포인터와 shared 원격 가능 포인터를 지원한다. 인터페이스는 이 포인터들이 자료구조가 일반적으로 사용되는 모든 장소에서 사용하기 적합하게 만든다.

-	**memory representation**

원격 가능 포인터가 로컬인지 원격인지에 따라 다른 형식을 채택하게 된다.

<p align="center">
    <img src="https://user-images.githubusercontent.com/56579239/176814119-1e149708-c40b-47f1-8d54-6d6c408e0d9e.png">
</p>
 
메모리가 로컬일 경우, 하위 47비트에는 가상 메모리 주소를 포함하고 상위 17비트는 다음을 표시한다.
-	D 비트: 작업 중인지, 수정이 있는지
-	P 비트: 현재 로컬인지
-	H 비트: 현재 객체가 hot 한지, 사용 중인지
-	S 비트: 공유 포인터인지, 고유 포인터인지
-	E 비트: evacuation 처리가 될 객체인지
바이트가 가장 작은 읽기/쓰기 단위이므로, AIFM은 D, E, H 비트를 바이트 정렬하여 돌연변이 스레드와 evacuators가 동시에 원자적으로 액세스 할 수 있도록 한다.

<p align="center">
    <img src="https://user-images.githubusercontent.com/56579239/176814209-6884e36b-db7b-4a9e-984c-8939849d5dfd.png">
</p>
 
메모리가 원격일 경우, 메모리에는 자료구조 ID, 객체 크기 및 객체 ID와 같은 원격 메모리에서 객체를 검색하는 데 도움이 되는 메타 데이터가 포함된다. 각 자료구조 인스턴스에는 런타임에 의해 관리되는 고유한 자료구조 ID가 있다. 객체 ID는 자료구조 객체 식별자를 가리키며(해시 테이블의 key처럼), 원격 메모리 서버에서 객체를 식별하는 데 사용된다.

C++의 std::unique_ptr과 일치하는 unique 원격 가능 포인터는 일반적인 64비트 포인터와 같은 사이즈를 가지고 있다. 반면에 std::shared_ptr 같이 shared 포인터들은 128비트이다. 포인터 할당을 허용하는 C++의 shared_ptr와 같은 AIFM의 원격 가능 공유 포인터는 두 가지 면에서 유니크 포인터와 다르다.
1.	S 비트가 1로 설정된다.
2.	동일한 객체에 공유 포인터를 연결하기 위한 추가 8 바이트를 가지고 있다.

AIFM의 런타임은 참조된 객체를 제거하거나 로컬로 이동할 때, 체인을 통과하여 모든 공유 포인터를 업데이트 한다. AIFM의 런타임은 참조된 객체를 지우거나 로컬로 이동시킬 때, 모든 공유 포인터를 업데이트하기 위해 체인을 순회한다.

-	**API**

<p align="center">
    <img src="https://user-images.githubusercontent.com/56579239/176814329-7a10489e-d375-4718-b773-085ea2915dc1.png">
</p>

다음은 Remoteable unique 포인터의 API이다. (공유 포인터도 거의 똑같음.) 여기에는 두 가지 생성자가 있다. 하나는 이미 로컬인 객체에 대한 것이고, 다른 하나는 현재 원격인 객체에 대한 것이다. 두 번째 생성자는 자료구조가 현재 원격인 객체에 대한 원격 포인터를 형성할 수 있도록 한다. 이것은 자료구조 엔지니어가 객체를 원격에서 로컬로 가져올 필요 없이 원격 객체를 참조할 수 있도록 도와준다.

-	**역참조**

역참조 메소드가 호출되면, 런타임은 원격 가능 포인터의 현재 비트를 검사한다. 개체가 로컬인 경우, H 비트를 설정하고 포인터에 저장된 주소를 반환한다. 그렇지 않으면, 런타임은 원격 서버에서 이를 가져와 H 비트, D 비트를 설정하고 로컬 포인터를 데이터로 반환한다.

API의 과제는 역참조 데이터의 로컬 수명을 관리하는 것이다: 응용이 포인터를 역참조 하는 동안 런타임은 객체를 스왑아웃 하면 안 된다. 런타임은 데이터가 사용되고 있는지를 알기에는 정보가 부족하다. AIFM은 응용의 semantics를 활용하여 로컬의 수명을 AIFM의 역참조 범위와 연결하는 것이다.

<h4> 3.2.2. 역참조 범위 </h4>

<p align="center">
    <img src="https://user-images.githubusercontent.com/56579239/176814421-e5baec0f-1825-4c95-97d2-e4d5afe79dba.png">
</p>

개발자는 원격 객체에 접근하기 전에 DerefScope를 무조건 실행해야 한다. AIFM API는 DerefScope& 명령을 실행으로써 컴파일 타임 검사를 제공한다 (이것은 원격 가능 포인터가 연산자 오버로딩을 하지 않고 자신의 역참조 메소드를 가지고 있는 이유이다).

DerefScope는 evacuation fence를 만들고, 파괴될 때까지 evacuation을 막는다. 따라서 모든 로컬 역참조 데이터의 수명은 스코프 수명과 연결된다. 역참조 범위 밖에서 역참조 데이터에 접근하는 것은 불가능한 동작이다. 

스코프 API는 C++11의 std:weak_ptr과 유사한데, DerefScope의 수명은 원격 포인터의 수명과 별개이다. 원격 가능 포인터는 데이터가 원격으로 스왑한 경우에도 여전히 활성 상태일 수 있다.

<h4> 3.2.3. Evacuation 처리기 </h4>

Evacuation 시 커스텀 로직을 필요로 하는 객체가 있을 수 있다. 예를 들어, AIFM이 해시 테이블에 포함된 객체를 Evacuate 때, 해시 테이블은 로컬 공간의 절약을 위해 해싱(키와 데이터의 포인터)을 제거하는 Evacuation handlers를 등록할 것이다. 향후 키에 대한 조회 누락은 키와 포인터를 재구성하여 해시 테이블에 추가한다. AIFM은 이러한 목적을 위해 evacuation handlers를 제공하여, 개발자들이 런타임 evacuation에 자료구조 semantics를 통합할 수 있도록 한다.

<p align="center">
    <img src="https://user-images.githubusercontent.com/56579239/176814547-5d570475-3417-4da5-abe9-72289f174fcd.png">
</p>
 
evacuation handlers는 런타임이 객체의 로컬 메모리를 free하기 바로 전, 객체를 원격 서버로 evacuating시킬 때 호출된다. 런타임에는 제거되어야 할 객체와 런타임이 객체를 원격으로 전달하도록 하는 함수를 EvacHandler를 전달한다. 첫 번째 인수는 handler가 객체를 복사하기 전에 객체를 수정(내장된 포인터의 states 수정)하고 복사 후 로컬 자료구조를 정리할 수 있게 한다(해시 테이블 인덱스에서 포인터 제거). 두 번째 인수는 객체를 원격으로 복사하는 타이밍에 유연성을 제공한다.

자료구조 개발자는 RegisterEvacHandler를 호출하여 evacuation handlers를 등록한다. evacuation handler는 자료구조 엔지니어가 일관되게 사용하는, 자료구조에서 생성자에 할당된 자료구조 ID에 연결된다. 이러한 방식으로 런타임은 적절한 핸들러를 호출하여, 동일한 자료구조의 다른 인스턴스나 다른 자료구조가 동일한 응용에 공존한다.

<h4> 3.2.4. 원격 장치 </h4>

<p align="center">
    <img src="https://user-images.githubusercontent.com/56579239/176821673-0d306054-0c86-4627-b4b4-be6efa60fe99.png">
</p>

AIFM의 RemDevice는 원격 메모리 서버에 기능을 제공한다. 원격 디바이스는 기본적으로 Key-Value 저장소 추상화를 사용한다: 원격 포인터를 역참조 하면, 런타임은 자료구조 ID와 객체 ID를 원격 서버로 보낸다. 원격 서버는 객체를 자료구조 ID와 객체 ID를 이용하여 찾고, 객체 데이터를 보낸다. 객체를 evacuate할 때, 런타임은 객체의 ID와 객체 데이터를 원격 서버로 전송한다.

AIFM은 자료구조 엔지니어에게 기본 동작에 원격 서버의 custom active components를 통합하여 유연성을 제공한다. 자료구조 엔지니어가 구현한 자료구조를 원격 장치에 등록함으로써 수행된다. custom active components는 로컬에서 객체를 가져오는 것보다 원격 메모리에서 명령을 수행함으로써 더욱 효율적으로 만들기 때문에 응용의 컴퓨팅 강도가 낮을 때 특히 유용하다. 

- `register_active_component`: 구현한 컴포넌트 원격 서버에 등록
- `constructor`, `destructor`: 컴포넌트를 인스턴스화 하고 소멸
- `read`, `write`, `delete`: 로컬과 원격 서버 간의 상호작용 메소드
- `compute`: 사용자 정의 함수를 호출하여 가벼운 계산 실행

Remote active components는 해시 테이블과 데이터 프레임의 성능을 향상시키기 위해 구현됐다.

<h4> 3.2.5. Semantic Hints </h4>

<h5> 1.	Hotness Tracking </h5>
원격 포인터를 역참조하기 위해, 사용자는 포인터의 hot bit를 설정하는 라이브러리를 호출한다. evacuator 할 때, evacuator는 hot bit를 초기화 한다.

AIFM 초기화는 개발자가 포인터에 사용할 hot bits(최대 8개)와 자료구조 ID에 의한 대체 정책을 사용자 정의할 수 있게 한다. AIFM은 여러 hot bit를 사용하여 CLOCK 교체를 지원한다.

<h5> 2.	Prefetching </h5>
AIFM은 스레드 별로 역참조 위치를 기록하는 윈도우를 유지하고 FSM을 사용하여 향후 액세스를 예측하기 위해 자료구조가 사용할 수 있는 라이브러리를 포함한다. 이 라이브러리는 역참조 때마다 윈도우와 FSM을 업데이트 한다. FSM은 순차 접근 및 strided 접근의 패턴을 검출한다.

패턴이 탐지되면, 원격 서버에서 객체를 스왑인 하는 prefetcher 스레드를 시작한다. 충분한 prefetch 기능을 사용하면, 응용 스레드는 원격 포인터를 역참조 할 때 항상 로컬 메모리에 액세스할 수 있다. 

<h5> 3.	Nontemporal Access </h5>
시간 지역성 없는 객체에 대한 원격 가능 포인터의 경우, 객체 데이터를 저장하는 데 로컬 메모리를 사용하는 것을 제한하는 것이 타당하다. 이는 자료구조 엔지니어가 다시 접근할 가능성이 낮다고 알고 있는 데이터로 인해 여러 자료구조와 공유되는 로컬 메모리가 오염되는 것을 방지한다. 

<p align="center">
    <img src="https://user-images.githubusercontent.com/56579239/176821866-d603d8ae-837f-41d6-8233-048b7a68bf44.png">
</p> 

이를 위해 AIFM의 포인터 API는 Nontemporal 역참조를 지원한다. 실제 evacuation는 DerefScope가 종료된 후에만 수행되지만, `rmt_ptr`에 의해 지정된 객체가 회수 가능한 것으로 표시된다. 언급이 없으면, 기본적으로 역참조는 temporal이다.

### 3.3 AIFM 런타임
AIFM의 런타임은 그린 스레드, kernel-bypass TCP/IP networking stack, pauseless 메모리 evacuator를 기반으로 한다. 응용은 런타임을 사용자 공간 프로세스에 연결한다. 이를 통해 AIFM의 추상화와 함께 런타임을 공동 설계할 수 있으며 OS 커널 추상화에 의존하지 않고 고성능 원거리 메모리를 제공한다.

런**타임 설계를 안내하는 두 가지 높은 수준의 목표**
1. 런타임은 원격 메모리에서 객체를 가져올 때 피할 수 없는 지연 시간 동안 대기하는 사이클을 생산적으로 사용해야 한다.
2. 응용 스레드는 메모리 evacuator를 기다릴 필요가 없어야 합니다.

<h4> 3.3.1. Hide Remote Access Latency </h4>
fetch 중에 유용한 작업을 수행하여 원격 메모리에서 데이터를 가져오는 지연 시간을 숨기려고 한다. AIFM은 다른 접근 방식을 취합니다. 원격 데이터 가져오기를 기다리는 동안 응용 작업을 수행하기 위해 적은 오버헤드의 그린 스레드에 의존한다.

각 돌연변이 스레드는 원격 객체를 가져와야 할 때마다 블록하고, 원격 메모리에 접근한다. 이 때 다른 돌연변이 스레드가 실행되어 사용 가능한 CPU 사이클을 생산적으로 사용할 수 있다. 게다가 AIFM의 런타임은 미래에 역참조될 것으로 예측되는 객체를 스왑하기 위해 prefetcher 스레드를 생성하므로 예측이 정확할 때 돌연변이 스레드를 차단하지 않을 수 있다.

AIFM은 그린 스레드를 사용하여 응용 처리량의 낭비 없이 네트워크 지연 시간을 견디며 네트워크 완성을 위해 바쁜 대기를 수행하는 시스템보다 더 적은 주기를 낭비한다.

<h4> 3.3.2. Remotable Memory Layout </h4>

<p align="center">
    <img src="https://user-images.githubusercontent.com/56579239/176844769-fac1621d-536a-40f5-804b-0cee75c85e7d.png">
</p> 

다음은 AIFM의 로컬 원격 가능 메모리의 도표이다. AIFM에는 free list, temporal used list, non-temporal used list 세 가지 글로벌 리스트가 있다. 각 리스트에는 많은 로그가 저장되고 각 로그에는 많은 객체가 저장된다. PCAB는 새로운 객체를 할당하기 위해 두 개의 사용 가능한 로그를 보관하고 있으며 하나는 시간적 객체에 대한 로그이고 다른 하나는 비시간적 객체에 대한 로그이다. 로그에는 시간적 또는 시간적 데이터를 저장하는지 여부를 나타내는 1B 헤더가 있고, 나머지 공간에는 객체가 저장된다.

AIFM에 의해 관리되는 로컬 메모리는 **로그 구조 메모리**의 개념을 수용한다. 로그 크기는 2MB로, 큰 페이지를 할당하여 TLB 누락 수를 줄이는 데 도움이 된다. 코어 확장성을 위해 각 코어는 새로운 할당을 위한 2개의 로그를 소유한다. 로그는 PCAB에 보관된다. 

객체를 할당하기 위해 런타임은 먼저 PCAB 안의 로그에 할당을 시도한다. 로그의 공간이 부족하면, 런타임은 로그를 글로벌 non-temporal 또는 temporal used list에 추가하고 global free list에서 새 로그를 가져온다. 객체를 해방하기 위해, 런타임은 객체를 free로 표시한다. 

<h4> 3.3.3. Pauseless Memory Evacuator </h4>
메모리 압박 속에서, 런타임 메모리 evacuator는 cold 객체를 원격 장치로 이동시킨다. 많은 GC처럼, AIFM의 핵심은 런타임이 로컬 메모리를 비울 때 돌연변이 스레드를 병행성 있게 동작하는 것이다. Evacuator는 한 동작에 4가지 페이즈를 실행한다. 

Race condition(mutator와 evacuator의 경쟁)에서 정확성을 보장하기 위해, evacuator는 불변성을 유지한다(e 비트 설정). RCU writer wait는 모든 돌연변이가 불변성 안에서 실행 시점을 강화하기 위해 설정 비트를 관찰하는 것을 보장한다.

<h5> 1. Log Selection Phase. </h5>
Evacuator의 목표는 `min_free_ratio` 상의 로컬 free 메모리 비율을 유지하는 것이다. Evacuator의Master thread는 evacuate될 로그의 `total_log_cnts` 정한다. Evacuator는 non-temporal object에 우선 순위를 두면서 FIFO 순서에 따라 global non-temporal used list에서 로그를 고르고, 필요에 따라 global temporal used list에서 고른다. AIFM은 로그를 age나 사용빈도에 따라 우선순위를 지정하는 것처럼 더욱 정교한 스키마를 사용할 수 있다.

<h5> 2. Concurrent Marking Phase. </h5>
Evacuation의 master thread는 작업 스레드를 생성하고 그 중에서 선택된 로그들로 나눈다. 각각의 작업 스레드는 로그 안의 객체를 통해 살아있는 객체를 찾는다. 각각의 작업은 헤더 포인터의 주소에서 시작하여 포인터 체인을 횡단하여 객체의 원격 가능한 포인터의 evacuation 비트를 설정한다. 이것은 evacuation될 객체를 표시한다.

<h5> 3. Evacuator Waiting Phase. </h5>
AIFM은 RCU 동기화에 영감을 받은 접근법을 사용한다. AIFM의 런타임은 동기화 오버헤드를 evacuator로 이동시킴으로써 돌연변이를 RCU reader처럼 다루고, evacuator master 스레드를 RCU writer처럼 다룬다. 결과적으로 evacuator master 스레드는 모든 돌연변이 스레드가 최근 evacuation bit 설정을 확인하는 것을 보장하기 위해 짧은 시간을 기다린다.

런타임은 객체가 돌연변이 스레드에 의해 역참조 되지 않을 때, evacuate할 수 있다. 돌연변이 스레드는 객체를 PCAB의 다른 로그에 복사한 다음, 헤드 원격 포인터(동기화 지점 역할)에 CAS를 실행하여 제거 비트를 지우고 현재 비트를 설정하고 새 데이터 위치를 설정한다. CAS는 evacuator와 같이 실행한다. 

CAS가 성공하면, 돌연변이 스레드는 아직 evacuate 되지 않은 객체를 복사하여 로컬 참조를 포함하도록 한다. 그런 다음 돌연변이는 포인터 체인의 모든 포인터를 헤드 포인터 메타데이터로 업데이트하고 실행을 계속한다. 

CAS가 실패할 경우, evaucator는 이미 원격 가능 포인터를 원격 상태로 변경했기 때문에, 돌연변이 스레드의 객체 복사본이 손상되었을 수 있다. 결과적으로, 돌연변이는 자신이 만든 복사본을 자유롭게 하고 원격 참조를 얻는다.

<h5> 4. Concurrent Evacuation Phase. </h5>
마스터 스레드는 객체를 evacuate하기 위한 작업 스레드를 더욱 생성하고, evacuation handler를 실행한다. 그리고 마스터 스레드는 작업을 선택된 로그로 나눈다. 각각의 cold 객체는, 작업이 원격으로 복사하고, 헤더 원격 포인터에 CAS를 실행하여(mutator check) 현재 비트를 지우고 원격 포인터 메타데이터를 설정한다. 

CAS가 성공하면, 객체는 evacuate 되고, 작업은 포인터를 포인터체인의 헤더 포인터 메타데이터로 업데이트하고, evacuation handler를 호출한다. 

<h4> 3.3.4. Co-design with Thread Sceduler </h4>
런타임이 메모리 압박에 있으면, evacuation은 급한 작업이다. 하지만 메모리가 돌연변이 스레드로 차 evacuation의 용량이 부족할 수 있다. 이것은 많은 양의 돌연변이 스레드가 evacuation이 메모리를 비우는 것보다 빠르게 메모리에 할당될 수 있다는 것이다. 그리고 evacuation이 역참조 스코프 안의 돌여변이 스레드를 블록시키는 딜레마가 있다. 

스케줄러는 돌연변이 스레드를 실행시켜 evacuation이 블록되지 않도록 해야한다. 그러나 돌연변이 스레드를 실행시키는 것은 메모리를 많이 소비한다.

이런 이유로, AIFM의 런타임 그린 스케줄러는 우선순위를 부여하기 위해 돌연변이 스레드와 evacuation 스레드를 함께 설계한다. 설계 내용은 다음과 같다. 
- 각각의 스레드는 AIFM에 의해 설정되는 status을 유지하여, 스케줄러가 스레드가 역참조 스코프 안에 있는지 알게한다. 스케줄러는 멀티 큐 알고리즘을 실행하고, 역참조 스코프 안의 돌연변이 스레드에 최우선순위를 부여한다. 그리고 evacuation 스레드에 두 번째 우선순위를 부여하고, 다른 돌연변이 스레드에 세 번째 우선순위를 부여한다. 
- 시스템의 메모리가 적을 때 발생하는 우선순위 역전을 피하기 위해, AIFM 런타임의 할당 함수는 재스케줄링을 위해 스케줄러에 코어를 다시 반환하도록 모든 실행 중인 스레드에 신호를 발생시킨다.
